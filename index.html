<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <meta name="theme-color" content="#0b0f1a" />
  <title>Endless Auto-Shooter</title>
  <style>
    :root{--bg:#0b0f1a;--fg:#e6edf3;--muted:#8aa0b3;--acc:#59f1c8}
    html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;overflow:hidden}
    canvas{display:block;width:100vw;height:100vh;touch-action:none}
    #ui{position:fixed;inset:0;pointer-events:none;display:grid;grid-template-rows:auto 1fr auto;padding:12px}
    #hud{display:flex;gap:12px;align-items:center;justify-content:space-between}
    .pill{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.08);padding:6px 10px;border-radius:999px;font-weight:600}
    #titleBar{display:flex;gap:10px;align-items:center}
    #titleBar .dot{width:8px;height:8px;border-radius:50%;background:var(--acc);box-shadow:0 0 8px var(--acc)}
    #centerMsg{position:fixed;inset:0;display:grid;place-items:center;text-align:center;padding:24px;pointer-events:auto}
    #centerCard{max-width:640px;width:min(92vw,640px);background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);border-radius:16px;padding:20px 16px;backdrop-filter:blur(6px)}
    #centerCard h2{margin:0 0 8px;font-size:26px}
    #centerCard p{margin:0;color:var(--muted)}
    #centerCard .btns{margin-top:14px;display:flex;gap:10px;justify-content:center}
    button{pointer-events:auto;cursor:pointer;border:1px solid rgba(255,255,255,.18);background:rgba(255,255,255,.08);color:var(--fg);border-radius:12px;padding:10px 14px;font-weight:700;letter-spacing:.3px;transition:transform .06s ease,background .2s ease}
    button:hover{background:rgba(255,255,255,.14)} button:active{transform:translateY(1px) scale(.995)}
    #controls{pointer-events:none;position:fixed;left:0;right:0;bottom:calc(18px + env(safe-area-inset-bottom));display:flex;justify-content:space-between;padding:0 18px;gap:12px}
    .ctrlBtn{pointer-events:auto;width:44vw;max-width:280px;height:64px;border-radius:16px;border:1px dashed rgba(255,255,255,.22);background:rgba(255,255,255,.05);font-weight:800;backdrop-filter:blur(6px)}
    @media (min-width:900px){#controls{display:none}}
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div id="ui" aria-hidden="true">
    <div id="hud">
      <div id="titleBar"><div class="dot"></div><div>Endless Auto-Shooter</div></div>
      <div style="display:flex;gap:10px;align-items:center">
        <div id="score" class="pill">Score: 0</div>
        <div id="dist" class="pill">Distanz: 0 m</div>
        <div id="mult" class="pill">x1.0</div>
        <button id="btnAudio" title="Musik/Sound umschalten">ðŸ”Š</button>
      </div>
    </div>
  </div>

  <div id="centerMsg">
    <div id="centerCard">
      <h2>Tippe zum Starten</h2>
      <p>Links/Rechts: Tippe linke oder rechte BildschirmhÃ¤lfte. Auto-Schuss. Pause: Leertaste/erneut tippen.</p>
      <div class="btns">
        <button id="btnStart">Start</button>
        <button id="btnHow">Hilfe</button>
      </div>
    </div>
  </div>

  <div id="controls">
    <button id="btnLeft" class="ctrlBtn">âŸµ Links</button>
    <button id="btnRight" class="ctrlBtn">Rechts âŸ¶</button>
  </div>

<script>
(() => {
  'use strict';

  // DOM refs
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const hudScore = document.getElementById('score');
  const hudDist  = document.getElementById('dist');
  const hudMult  = document.getElementById('mult');
  const centerMsg= document.getElementById('centerMsg');
  const btnStart = document.getElementById('btnStart');
  const btnHow   = document.getElementById('btnHow');
  const btnLeft  = document.getElementById('btnLeft');
  const btnRight = document.getElementById('btnRight');
  const btnAudio = document.getElementById('btnAudio');

  // --- Fix: player vor resize() deklarieren und in resize() nur nutzen, wenn vorhanden
  let player = null;

  let DPR=1, W=0, H=0;
  function resize(){
    DPR = window.devicePixelRatio || 1;
    W = canvas.width  = Math.max(320, Math.floor(window.innerWidth * DPR));
    H = canvas.height = Math.max(480, Math.floor(window.innerHeight * DPR));
    canvas.style.width  = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    laneX = computeLanes();
    if (player) player.y = H * 0.78; // <- nur wenn bereits definiert
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // Game constants
  const LANES=3, LANE_MARGIN=0.17;
  const BULLET_SPEED = 9*DPR;
  const ENEMY_BASE_SPEED=3.1*DPR, ENEMY_SPAWN_BASE=900;
  const DIST_PER_SEC=25, POWER_SPAWN_EVERY=5200;
  const PLAYER_SIZE=28*DPR;

  function computeLanes(){
    const pad=W*LANE_MARGIN, usable=W-pad*2;
    return Array.from({length:LANES},(_,i)=>Math.round(pad + usable*(i+0.5)/LANES));
  }
  let laneX = computeLanes();

  const State={INIT:0,RUN:1,DEAD:2,PAUSE:3}; let state=State.INIT;
  const bullets=[], enemies=[], particles=[], powerups=[];
  let dist=0, score=0, multiplier=1, lastTime=0, spawnTimer=0, runTime=0, powerTimer=0;
  const ActivePU={ rapid:0, spread:0 };

  // Audio (mobile-safe)
  let audio={ ctx:null, master:null, musicGain:null, sfxGain:null, loopId:null, enabled:true, unlocked:false };
  function initAudio(){
    if (audio.ctx) return;
    const AC = window.AudioContext || window.webkitAudioContext;
    if (!AC) return;
    const ctxA = new AC();
    const master = ctxA.createGain(); master.gain.value=0.6; master.connect(ctxA.destination);
    const musicGain = ctxA.createGain(); musicGain.gain.value=0.25; musicGain.connect(master);
    const sfxGain   = ctxA.createGain(); sfxGain.gain.value=0.8;   sfxGain.connect(master);
    audio = { ...audio, ctx:ctxA, master, musicGain, sfxGain };
  }
  function unlockAudio(){
    if (!audio.ctx || audio.unlocked) return;
    const o = audio.ctx.createOscillator(); const g = audio.ctx.createGain();
    g.gain.value = 0.00001; o.connect(g); g.connect(audio.ctx.destination);
    o.start(); o.stop(audio.ctx.currentTime + 0.01);
    if (audio.ctx.state === 'suspended') audio.ctx.resume();
    audio.unlocked = true;
  }
  function startMusic(){
    if (!audio.ctx || !audio.enabled) return;
    stopMusic();
    const scale=[0,3,5,7,10], base=220, g=audio.musicGain;
    let step=0;
    audio.loopId = setInterval(()=>{
      const semis=scale[step%scale.length]+(Math.floor(step/scale.length)%2===0?12:24);
      const f= base*Math.pow(2, semis/12);
      tone(f,0.12,0.003,0.08,'sawtooth',g,0.002);
      if (step%8===0) tone(base/2,0.25,0.005,0.22,'triangle',g,0.004);
      step++;
    }, 140);
  }
  function stopMusic(){ if (audio.loopId){ clearInterval(audio.loopId); audio.loopId=null; } }
  function toggleAudio(){ audio.enabled=!audio.enabled; btnAudio.textContent = audio.enabled?'ðŸ”Š':'ðŸ”ˆ'; if (!audio.enabled) stopMusic(); else if (state===State.RUN) startMusic(); }
  btnAudio.addEventListener('click', ()=>{ initAudio(); unlockAudio(); toggleAudio(); });

  function tone(freq,dur,attack,release,type,gainNode,glide=0){
    if (!audio.ctx) return;
    const now=audio.ctx.currentTime;
    const osc=audio.ctx.createOscillator(); osc.type=type;
    const g=audio.ctx.createGain(); g.gain.setValueAtTime(0,now);
    g.gain.linearRampToValueAtTime(1,now+attack);
    g.gain.linearRampToValueAtTime(0.0001, now+attack+dur+release);
    osc.connect(g); g.connect(gainNode);
    const p=osc.frequency; p.setValueAtTime(freq*(1+glide),now); p.exponentialRampToValueAtTime(freq, now+attack+dur*0.5);
    osc.start(now); osc.stop(now+attack+dur+release+0.02);
  }

  // Input
  function moveLane(dir){ if(state!==State.RUN) return; const nl=Math.min(LANES-1,Math.max(0,(player.lane||1)+dir)); if(nl!==(player.lane||1)){ player.lane=nl; player.moveAnim=1; } }
  window.addEventListener('keydown',e=>{ if(e.repeat) return; if(e.code==='ArrowLeft'||e.code==='KeyA') moveLane(-1); if(e.code==='ArrowRight'||e.code==='KeyD') moveLane(1); if(e.code==='Space') togglePause(); });

  canvas.addEventListener('pointerdown', (e)=>{
    initAudio(); unlockAudio();
    if (state!==State.RUN) { startGame(); return; }
    const mid = window.innerWidth/2;
    if (e.clientX < mid) moveLane(-1); else moveLane(1);
  }, {passive:true});

  document.addEventListener('visibilitychange', ()=>{ if (!audio.ctx) return; if (document.hidden) stopMusic(); else if (state===State.RUN && audio.enabled) startMusic(); });

  btnStart.addEventListener('click', ()=>{ initAudio(); unlockAudio(); startGame(); });
  btnHow.addEventListener('click', ()=>showCenter('So spielst du','Tippe links/rechts zum Ausweichen. Auto-Schuss. Sammle Power-Ups. Erster Tap schaltet Ton frei.') );
  btnLeft .addEventListener('click', ()=>moveLane(-1));
  btnRight.addEventListener('click', ()=>moveLane(1));

  function showCenter(title, subtitle){
    const card=document.getElementById('centerCard');
    card.querySelector('h2').textContent=title;
    card.querySelector('p').textContent=subtitle;
    centerMsg.style.display='grid';
  }

  function spawnEnemy(){
    const lane=(Math.random()*LANES)|0;
    const speed=ENEMY_BASE_SPEED+(runTime/60000)*2*DPR; const size=24*DPR;
    enemies.push({ lane, x:laneX[lane], y:-size, size, hp:1, speed });
  }
  function spawnPowerUp(){
    const lane=(Math.random()*LANES)|0; const size=18*DPR; const types=['rapid','spread','shield'];
    const type=types[(Math.random()*types.length)|0];
    powerups.push({ lane, x:laneX[lane], y:-size*2, size, type, speed: ENEMY_BASE_SPEED*0.9 });
  }
  function applyPowerUp(type){
    if (type==='shield'){ player.shield=true; return; }
    if (type==='rapid'){ ActivePU.rapid=12000; }
    if (type==='spread'){ ActivePU.spread=12000; }
  }
  function updatePowerTimers(dt){
    if (ActivePU.rapid>0) ActivePU.rapid -= dt;
    if (ActivePU.spread>0) ActivePU.spread -= dt;
    player.fireInterval = Math.max(70, (player.baseFire||180) - (ActivePU.rapid>0?90:0) - runTime/1200);
  }
  function shoot(){
    const base={ x:player.x, y:player.y-player.size*0.7, vy:-BULLET_SPEED, size:6*DPR, life:2000 };
    bullets.push({ ...base });
    if (ActivePU.spread>0){ bullets.push({ ...base, x:base.x-16*DPR }); bullets.push({ ...base, x:base.x+16*DPR }); }
  }
  function circleHit(a,b){ const dx=a.x-b.x, dy=a.y-b.y; const r=a.size+b.size; return dx*dx+dy*dy<=r*r; }

  function drawBG(dt){ ctx.fillStyle='#0b0f1a'; ctx.fillRect(0,0,W,H); }
  function drawPlayer(p){
    const s=p.size, x=p.x, y=p.y;
    ctx.save(); ctx.translate(x,y);
    if (p.shield){ ctx.beginPath(); ctx.arc(0,0,s*1.25,0,Math.PI*2); ctx.strokeStyle='rgba(183,148,246,0.6)'; ctx.lineWidth=3*DPR; ctx.stroke(); }
    ctx.beginPath(); ctx.moveTo(0,-s*1.0); ctx.lineTo(-s*0.7,s*0.9); ctx.lineTo(s*0.7,s*0.9); ctx.closePath();
    ctx.strokeStyle='rgba(89,241,200,0.9)'; ctx.lineWidth=3*DPR; ctx.stroke();
    ctx.restore();
  }
  function drawEnemy(e){ ctx.save(); ctx.translate(e.x,e.y); const r=e.size; ctx.beginPath(); ctx.rect(-r,-r,r*2,r*2); ctx.strokeStyle='rgba(255,92,122,0.9)'; ctx.lineWidth=3*DPR; ctx.stroke(); ctx.restore(); }
  function drawBullet(b){ ctx.save(); ctx.translate(b.x,b.y); ctx.beginPath(); ctx.arc(0,0,b.size,0,Math.PI*2); ctx.fillStyle='rgba(89,241,200,0.95)'; ctx.fill(); ctx.restore(); }
  function drawPowerUp(pu){ ctx.save(); ctx.translate(pu.x,pu.y); const r=pu.size; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.strokeStyle='rgba(255,209,102,0.9)'; ctx.lineWidth=3*DPR; ctx.stroke(); ctx.restore(); }

  function drawAll(dt){
    drawBG(dt);
    for (const e of enemies) drawEnemy(e);
    for (const b of bullets) drawBullet(b);
    for (const pu of powerups) drawPowerUp(pu);
    drawPlayer(player);
  }

  function startGame(){
    state=State.RUN; centerMsg.style.display='none';
    initAudio(); unlockAudio(); if (audio.enabled) startMusic();
    resetRun();
  }
  function resetRun(){
    bullets.length=enemies.length=powerups.length=particles.length=0;
    dist=0; score=0; multiplier=1; spawnTimer=0; runTime=0; powerTimer=0; lastTime=0;
    player = { lane:1, x:laneX[1], y:H*0.78, size:PLAYER_SIZE, fireCd:0, baseFire:180, fireInterval:180, moveAnim:0, shield:false };
    hudScore.textContent='Score: 0'; hudDist.textContent='Distanz: 0 m'; hudMult.textContent='x1.0';
  }
  function togglePause(){ if (state===State.RUN){ state=State.PAUSE; stopMusic(); showCenter('Pausiert','Tippe, um fortzusetzen.'); } else if (state===State.PAUSE){ state=State.RUN; centerMsg.style.display='none'; if (audio.enabled) startMusic(); } }

  function loop(ts){
    if(!lastTime) lastTime=ts; const dt=ts-lastTime; lastTime=ts;
    if (state===State.RUN){
      runTime+=dt; dist+=(DIST_PER_SEC+runTime/3000)*(dt/1000); multiplier = 1+Math.min(4, Math.floor(runTime/15000));
      hudDist.textContent=`Distanz: ${Math.floor(dist)} m`; hudMult.textContent=`x${multiplier.toFixed(1)}`;

      const spawnEvery=Math.max(300, ENEMY_SPAWN_BASE-runTime*0.3); spawnTimer+=dt; if(spawnTimer>spawnEvery){ spawnTimer=0; spawnEnemy(); }
      powerTimer+=dt; if(powerTimer>POWER_SPAWN_EVERY){ powerTimer=0; spawnPowerUp(); }

      player.fireCd -= dt; if (player.fireCd<=0){ player.fireCd+=player.fireInterval; shoot(); }
      updatePowerTimers(dt);

      for (let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; b.y += -BULLET_SPEED; b.life -= dt; if (b.y<-20*DPR || b.life<=0) bullets.splice(i,1); }
      for (let i=enemies.length-1;i>=0;i--){ const e=enemies[i]; e.y += ENEMY_BASE_SPEED + (runTime/60000)*2*DPR; if (e.y - e.size > H+40*DPR){ enemies.splice(i,1); continue; }
        if (e.lane===player.lane){ const pHit={x:player.x,y:player.y,size:player.size*0.8}; if (circleHit(pHit,e)){ state=State.DEAD; stopMusic(); showCenter('Game Over',`Score: ${Math.floor(score)} Â· Distanz: ${Math.floor(dist)} m`); } }
      }
      outer: for (let i=enemies.length-1;i>=0;i--){ const e=enemies[i];
        for (let j=bullets.length-1;j>=0;j--){ const b=bullets[j];
          if (Math.abs(b.x-e.x)<e.size+14*DPR && Math.abs(b.y-e.y)<e.size+14*DPR){
            if (circleHit({x:b.x,y:b.y,size:b.size*0.9},{x:e.x,y:e.y,size:e.size})){
              bullets.splice(j,1); enemies.splice(i,1); score += 10*multiplier; hudScore.textContent = `Score: ${Math.floor(score)}`; continue outer;
            }
          }
        }
      }
    }
    drawAll(dt);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
